#!/usr/bin/python
"""ORM for index server."""
import os
import logging
from time import sleep
import peewee

# pylint: disable=too-few-public-methods

DB = peewee.MySQLDatabase(os.getenv('MYSQL_ENV_MYSQL_DATABASE', 'pacifica_uniqueid'),
                          host=os.getenv('MYSQL_PORT_3306_TCP_ADDR', '127.0.0.1'),
                          port=int(os.getenv('MYSQL_PORT_3306_TCP_PORT', 3306)),
                          user=os.getenv('MYSQL_ENV_MYSQL_USER', 'uniqueid'),
                          passwd=os.getenv('MYSQL_ENV_MYSQL_PASSWORD', 'uniqueid'))
DATABASE_SAVE_ATTEMPTS = 30
DATABASE_CONNECT_ATTEMPTS = 15
DATABASE_WAIT = 3


class BaseVersionedModel(peewee.Model):
    """
    Class to version rows and handle atomic updates.

    http://docs.peewee-orm.com/en/latest/peewee/hacks.html
    """

    version = peewee.IntegerField(default=1, index=True)

    def save_optimistic(self):
        """Alternative to the save() method that handles atomic updates."""
        if not self.id:
            # This is a new record, so the default logic is to perform an
            # INSERT. Ideally your model would also have a unique
            # constraint that made it impossible for two INSERTs to happen
            # at the same time.
            return self.save()

        # Update any data that has changed and bump the version counter.
        field_data = dict(self._data)
        current_version = field_data.pop('version', 1)
        field_data = self._prune_fields(field_data, self.dirty_fields)
        if not field_data:
            raise ValueError('No changes have been made.')

        ModelClass = type(self)
        field_data['version'] = ModelClass.version + 1  # Atomic increment.

        query = ModelClass.update(**field_data).where(
            (ModelClass.version == current_version) &
            (ModelClass.id == self.id))
        if query.execute() == 0:
            # No rows were updated, indicating another process has saved
            # a new version. How you handle this situation is up to you,
            # but for simplicity I'm just raising an exception.
            raise peewee.IntegrityError()
        else:
            # Increment local version to match what is now in the db.
            self.version += 1
            return True


class UniqueIndex(BaseVersionedModel):
    """Auto-generated by pwiz maps a python record to a mysql table."""

    idid = peewee.CharField(primary_key=True, db_column='id')
    index = peewee.BigIntegerField(db_column='index')

    class Meta(object):
        """Map to the database connected above."""

        database = DB
        only_save_dirty = True

    @classmethod
    def atomic(cls):
        """Get the atomic context or decorator."""
        # pylint: disable=no-member
        return cls._meta.database.atomic()
        # pylint: enable=no-member

    @classmethod
    def database_connect(cls):
        """
        Make sure database is connected.

        Trying to connect a second time doesnt cause any problems.
        """
        peewee_logger = logging.getLogger('peewee')
        peewee_logger.debug('Connecting to database.')
        # pylint: disable=no-member
        cls._meta.database.connect()
        # pylint: enable=no-member

    @classmethod
    def database_close(cls):
        """
        Close the database connection.

        Closing already closed database throws an error so catch it and continue on.
        """
        peewee_logger = logging.getLogger('peewee')
        peewee_logger.debug('Closing database connection.')
        try:
            # pylint: disable=no-member
            cls._meta.database.close()
            # pylint: enable=no-member
        except peewee.ProgrammingError:  # pragma no cover
            # error for closing an already closed database so continue on
            return


def update_index(id_range, id_mode):
    """Update the index for a mode and returns a unique start and stop index."""
    index = -1
    id_range = id_range
    if id_range and id_mode and id_range > 0:
        count = DATABASE_SAVE_ATTEMPTS
        while count:
            record = UniqueIndex.get_or_create(idid=id_mode, defaults={'index': 1})[0]
            index = int(record.index)
            record.index = index + id_range
            try:
                record.save_optimistic()
                count = 0
            except peewee.IntegrityError:
                count -= 1
                sleep(0.01)
                if not count:
                    index = id_range = -1
    else:
        index = -1
        id_range = int(-1)
    return (index, id_range)


def try_db_connect(attempts=0):
    """Try connecting to the db."""
    try:
        UniqueIndex.database_connect()
    except peewee.OperationalError as ex:
        if attempts < DATABASE_CONNECT_ATTEMPTS:
            sleep(DATABASE_WAIT)
            attempts += 1
            try_db_connect(attempts)
        else:
            raise ex
